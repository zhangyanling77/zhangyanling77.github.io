# 面试题收集

## 一、文件上传，实现分片上传、断点续传
### 前端部分（create-reac-app + antd + typescript)
* 创建项目并安装依赖
```bash
$ npx create-react-app my-upload --tempalte typescript
$ yarn add antd
$ cd my-upload
$ yarn start
```
高级配置可按照antd官方来进行配置，这里不做赘述。

* 修改App.tsx
```javascript
  import React, { Component } from 'react';
  import './App.less';
  import Upload from './Upload';

  class App extends Component {
    render() {
      return (
        <div className="App">
          <Upload />
        </div>
      );
    }
  }

  export default App;
```
* Upload.tsx
```javascript
  import React, { ChangeEvent, useState, useEffect } from 'react';
  import { Row, Col, Input, Button, Card, message } from 'antd';
  import { request } from './request';
  // 上传文件校验
  function allowUpload(file: File) {
    const isValidFileType = ["image/jpeg", "image/png", "image/gif", "video/mp4"].includes(file.type);
    if (!isValidFileType) {
      message.error('不支持此类文件上传');
    }
    // 文件大小的单位是字节  1024 bytes = 1 k * 1024 = 1 M * 1024 = 1 G
    const isLessThan2G = file.size < 1024 * 1024 * 1024 * 2;
    if (!isLessThan2G) {
        message.error('上传的文件不能大于2G');
    }
    return isValidFileType && isLessThan2G;
  }

  function Upload() {
      const [currentFile, setCurrentFile] = useState<File>();
      const [objectURL, setObjectURL] = useState<string>('');
      useEffect(() => {
          if (currentFile) {
              const reader = new FileReader();
              reader.addEventListener('load', () => setObjectURL(reader.result as string));
              reader.readAsDataURL(currentFile);
          }
      }, [currentFile]);
      function handleChange(event: ChangeEvent<HTMLInputElement>) {
          let file: File = event.target.files![0];
          setCurrentFile(file);
      }
      async function handleUpload() {
          if (!currentFile) {
              return message.error('你尚未选择文件');
          }
          if (!allowUpload(currentFile)) {
              return message.error('不支持此类文件的上传');
          }
          const formData = new FormData();
          formData.append('chunk', currentFile);//添加文件，字段名chunk
          formData.append('filename', currentFile.name); // 文件名
          const result = await request({
              url: '/upload',
              method: 'POST',
              data: formData
          });
          message.info('上传成功');
      }
      return (
         <Row>
            <Col span={12} style={{ padding: 20 }}>
              <Card>
                <Input type='file' style={{ width: 300 }} onChange={handleChange} />
                <Button type='primary' style={{ marginLeft: 10 }} onClick={handleUpload}>上传到服务器</Button>
              </Card>
            </Col>
            <Col span={12} style={{ padding: 20 }}>
              <Card
                title="预览效果"
                hoverable
                cover={objectURL && <img alt='' src={objectURL} />}
              >
                {currentFile && currentFile.name}
              </Card>
            </Col>
        </Row>
      )
  }

  export default Upload;
```
* request.tsx
```javascript
  interface OPTIONS {
    baseURL?: string;
    method: string;
    url: string;
    headers?: any;
    data: any;
  }
  export function request(options: OPTIONS): Promise<any> {
    let defaultOptions = {
        method: 'GET',
        baseURL: 'http://localhost:4000', // 服务器host
        headers: {},
        data: {},
    }
    options = { ...defaultOptions, ...options, headers: { ...defaultOptions.headers, ...(options.headers || {}) } };
    return new Promise(function (resolve: Function, reject: Function) {
        let xhr = new XMLHttpRequest();
        xhr.open(options.method, options.baseURL + options.url);
        for (let key in options.headers) {
            xhr.setRequestHeader(key, options.headers[key]);
        }
        xhr.responseType = 'json';
        xhr.onreadystatechange = function () {
            if (xhr.readyState == 4) {
                if (xhr.status === 200) {
                    resolve(xhr.response);
                } else {
                    reject(xhr.response);
                }
            }
        }
        xhr.send(options.data);
    });
  }
```

### 后端部分（express + typescript）
* 创建项目并安装依赖
```bash
$ mkdir upload-server && cd upload-server
$ npm init -y
$ npx tsconfig.json
$ yarn add fs-extra express morgan http-errors http-status-codes cors multer multiparty
$ yarn add @types/node cross-env typescript ts-node ts-node-dev nodemon -D
```
* 添加启动项目的script
```json
"scripts": {
  "dev": "cross-env PORT=4000 nodemon --exec ts-node --files ./src/www.ts",
  "utils": "ts-node ./src/utils.ts"
}
```
* app.ts
```javascript
import express, { Request, Response, NextFunction } from 'express';
import logger from 'morgan';
import { INTERNAL_SERVER_ERROR } from 'http-status-codes'; // 500
import createError from 'http-errors';
import cors from 'cors';
import path from 'path';
import fs from 'fs-extra';
import multiparty from 'multiparty'; // 处理文件上传
export const UPLOAD_DIR = path.resolve(__dirname, 'upload');
const app = express()

app.use(logger('dev'))
app.use(express.json())
app.use(express.urlencoded({ extended: true }))
app.use(cors())
app.use(express.static(UPLOAD_DIR))
// 上传文件
app.post('/upload', function(req:Request, res:Response, next:NextFunction) {
  const form = new multiparty.Form()
  form.parse(req, async (err:any, fields, files) => {
    if (err) {
      return next(err)
    }
    const filename = fields.filename[0]
    const chunk = files.chunk[0]
    await fs.move(chunk.path, path.resolve(UPLOAD_DIR, filename), { overwrite: true })
    res.json({ 
      success: true
    });
  })
})
app.use(function(_req:Request, _res:Response, next:NextFunction) {
  next(createError(404))
})

app.use(function(error:any, _req:Request, res:Response, _next:NextFunction) {
  res.status(error.status || INTERNAL_SERVER_ERROR)
  res.json({
    success: false,
    error
  })
})

export default app
```
* www.ts
```javascript
import app from './app';
import http from 'http';

const port = process.env.PORT || 4000;
const server = http.createServer(app);

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);
function onError(error: any) {
    console.error(error);
}
function onListening() {
    console.log('Listening on ' + port);
}
```
* utils.tsx
```javascript
import path from 'path';
import fs from 'fs-extra';
import { UPLOAD_DIR } from './app.ts'
const DEFAULT_SIZE = 1024 * 10;
export const TEMP_DIR = path.resolve(__dirname, 'temp');
// 拆分chunk
export const splitChunks = async (filename: string, size: number = DEFAULT_SIZE) => {
    let filePath = path.resolve(__dirname, filename);//要分割的文件绝对路径
    const chunksDir = path.resolve(TEMP_DIR, filename);//以文件名命名的临时目录，存放分割后的文件
    await fs.mkdirp(chunksDir);//递归创建目录
    let content = await fs.readFile(filePath);//Buffer 其实是一个字节数组 1个字节是8bit位
    let i = 0, current = 0, length = content.length;
    while (current < length) {
        await fs.writeFile(
            path.resolve(chunksDir, filename + '-' + i),
            content.slice(current, current + size)
        )
        i++;
        current += size;
    }
}
// splitChunks('tom.jpg');
// pipe
const pipeStream = (filePath:string, ws:WriteStream) => new Promise((resolve, reject) => {
  const rs = fs.createReadStream(filePath);
  rs.on('end', async () => {
    await fs.unlink(filePath)
    resolve()
  })
  rs.pipe(ws)
})
// 合并chunk
export const mergeChunks = async (filename: string, size: number = DEFAULT_SIZE) => {
  const filePath = path.resolve(UPLOAD_DIR, filename)
  const chunkDir = path.resolve(TEMP_DIR, filename)
  const chunkFiles = await fs.readdir(chunkDir) // 读取所有目录下的文件
  // 按文件名进行升序排序
  chunkFiles.sort((a, b) => Number(a.split('-')[1] - Number(b.split('-')[1])))
  await Promise.all(chunkFiles.map(chunkFile:string, index:number) => pipeStream(
    path.resolve(chunkDir, chunkFile),
    fs.createWriteStream(filePath, {
      start: size * index
    })
  ))
  await fs.rmdir(chunkDir) // 清空临时目录下的文件
}

// mergeChunks('tom.jpg');

```
